//All classes are written here and last class is Main


public class State {
	// Attributes
	public int Man = 3; // Men R
	public int wolf = 1; // Big Wolf R
	public int wolfy = 2; // small wolf R
	public int boat = 0; // Left 0 and 1 for right
	public static final State Goal = new State(0, 0, 0, 1);

	State Parent=null;
	// Constructor
	public State() {
	}

	// Copy constructor
	public State(State e) {
		Man = e.Man;
		wolf = e.wolf;
		wolfy = e.wolfy;
		boat = e.boat;
	}

	// Constructor
	public State(int m1, int w, int w2, int b) {
		Man = m1;
		wolf = w;
		wolfy = w2;
		boat = b;
	}

	// Method Checking Goal
	public boolean isGoal() {
		//System.out.print("{" + Man + " , " + wolfy + " , " + wolf + " , " + boat + "}");
		if (Man == Goal.Man && wolf == Goal.wolf && wolfy == Goal.wolfy && boat == Goal.boat) {
			System.out.println("is Goal");
			printPath();
			return true;
		} else
		//	System.out.println("Is not Goal (False).");
		return false;
	}

	public void printPath() {
		State temp=Parent;
		System.out.println("_______________________________________________");
		System.out.println("The Goal generated by :");
		do {
			temp.printstate();
		temp=temp.Parent;
			//System.out.println(temp);
}while(temp!=null);
}
	
	void findParent() {
		
		
	}
	
	public boolean isValid() {

		int wolfs = wolf + wolfy; // total number of wolfs

		// To check if number of them is valid
		if ((Man >= 0 && Man <= 3) && (wolf >= 0 && wolf <= 1) && (wolfy >= 0 && wolfy <= 2)) {

			// Switch ==> boat location
			switch (this.boat) {

			// left
			case 0:
				if ((Man < wolfs && Man > 0) || (Man == 0 && wolf == 0 && wolfy > 0)) {
			//		System.out.print("invalid Left");
					return false;
				}
				break;

			// right
			case 1:
				if ((Man < wolfs && Man > 0)) {
				//	System.out.print("invalid Right");
					return false;
				}
				break;
			}
			return true;
		} // end if
		return false;
	}

	public void printstate() {
		System.out.println("{ " + "Man: " + Man + " |" + " Big_Wolf: " + wolf + " |" + " wolfy: " + wolfy + "| "
				+ "Boat: " + boat + "}");

	}

	// Finding Successors
	public LinkedList<State> GenerateSuccessors(State e) {

		State temp = e;
		LinkedList<State> L1 = new LinkedList<State>();
		// prune
		if (!e.isValid())
			return L1;

		State test;
		// Boat on left side
		if (e.boat == 0) {

			// All possible Actions on Left side
			test = new State(e);
			test.Man -= 2; // (-2,0,0)
			if (test.isValid()) {
				test.boat = 1;
				L1.addLast(test);
			}

			test = new State(e);
			test.Man -= 1; // (-1,-1,0)
			test.wolf -= 1;
			if (test.isValid()) {
				test.boat = 1;
				L1.addLast(test);

			}

			test = new State(e);
			test.Man -= 1; // (-1,0,-1)
			test.wolfy -= 1;
			if (test.isValid()) {
				test.boat = 1;
				L1.addLast(test);

			}

			test = new State(e);
			test.wolf -= 1;// (0,-1,-1)
			test.wolfy -= 1;
			if (test.isValid()) {
				test.boat = 1;
				

				L1.addLast(test);

			}

			test = new State(e);
			test.wolf -= 1; // (0,-1,0)
			if (test.isValid()) {
				test.boat = 1;
				

				L1.addLast(test);

			}

			test = new State(e);
			test.Man -= 1;// (-1,0,0)
			if (test.isValid()) {
				test.boat = 1;
				

				L1.addLast(test);
			}

		} // end Left side

		else if (e.boat == 1) {
			// All possible Actions on Right side
			test = new State(e);
			test.Man += 2; // (+2,0,0)
			if (test.isValid()) {
				test.boat = 0;
				

				L1.addLast(test);
			}

			test = new State(e);
			test.Man += 1; // (+1,+1,0)
			test.wolf += 1;
			if (test.isValid()) {
				test.boat = 0;
				

				L1.addLast(test);
			}

			test = new State(e);
			test.Man += 1; // (+1,0,+1)
			test.wolfy += 1;
			if (test.isValid()) {
				test.boat = 0;
				

				L1.addLast(test);
			}

			test = new State(e);
			test.wolf += 1;// (0,+1,+1)
			test.wolfy += 1;
			if (test.isValid()) {
				test.boat = 0;
				

				L1.addLast(test);
			}

			test = new State(e);
			test.wolf += 1; // (0,+1,0)
			if (test.isValid()) {
				test.boat = 0;
				

				L1.addLast(test);
			}

			test = new State(e);
			test.Man += 1;// (+1,0,0)
			if (test.isValid()) {
				test.boat = 0;
				

				L1.addLast(test);
			}

		} // end right side

		// L1.findFirst();
		// while(!L1.last()) {
		// L1.retrieve().printstate();
		// L1.findNext();
		// }
		// L1.retrieve().printstate();

		return L1;
	}

}

_______________________________________________

import javax.security.sasl.SaslException;

//applying the bread first search algorithm
public class BFS {

	// Front & expaned Lists (Queue)
	LinkedList<State> frontier = new LinkedList<State>();
	LinkedList<State> expanded = new LinkedList<State>();
	LinkedList<State> L2 = new LinkedList<State>();

	public BFS() {
	}

	public boolean findGoal(State e) {
		State temp = new State(e);
		LinkedList<State> L1;
		frontier.addLast(e);

		// Checking Frontier
		temp = frontier.retrieve();
		while (!frontier.empty()) {
			frontier.findFirst();
			temp = frontier.retrieve();
			
			State suc;
			if (temp.isGoal())
				return true;
			frontier.remove();
			
			System.out.println("");
			System.out.print("The state:");
			temp.printstate();
			System.out.print("generates :");
			System.out.println("");
//			System.out.println("");
			
			
			expanded.addLast(temp);
			// Add Successors
			L1 = new LinkedList<State>();
			//temp.Parent=e.Parent;
			L1 = temp.GenerateSuccessors(temp);
			if (!L1.empty())
				L1.findFirst();

		

			while (!L1.empty()) {
				L1.findFirst();
				suc = L1.retrieve();

				if (!expanded.empty())
					if (Compare(suc)) {
						L1.remove();
					} else {
						suc.Parent=temp;
						frontier.addLast(suc);
						
						suc.printstate();
						L1.remove();
					}

			} // end L1 loop Successors
			if (!expanded.empty())
				if (Compare(temp)) {
				//	System.out.print("In expand list ");
				} else {
					frontier.addLast(L1.retrieve());
				}

		}

		return false;
	}// end FindGoal method

	public boolean Compare(State s) {
		expanded.findFirst();
		State temp = expanded.retrieve();
		while (!expanded.last()) {
			if ((s.Man == temp.Man) && (s.wolf == temp.wolf) && (s.wolfy == temp.wolfy) && (s.boat == temp.boat)) {
				return true;
			}
			expanded.findNext();
			temp = expanded.retrieve();
		}
		if ((s.Man == temp.Man) && (s.wolf == temp.wolf) && (s.wolfy == temp.wolfy) && (s.boat == temp.boat)) {
			return true;
		}
		return false;
	}



}

___________________________________________________________________________________________


public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		long startTime = System.currentTimeMillis();
		State s1 = new State(3, 1, 2, 0);
		BFS b1 = new BFS();

		b1.findGoal(s1);

		long endTime = System.currentTimeMillis();
		long searchTime = endTime - startTime;

		System.out.println();
		System.out.println();
		System.out.println("_______________________________________________");

		System.out.println("Time of excution is "+searchTime+" ms");
		
	}
}
